setTime(1656206817.919);E.setTimeZone(2)

const Layout = require('Layout');
  
const c = (function(){
  var bin=atob("n+0aesDuB3oBIxlG/e7nevju52qm7scK3+0VarTu5grx7hD6yL837kAKIO4AarDuQHpaAAL7AiJRQwbukBon7gZ6+O5mWtoHx+4lagPxAQNMvzDuZgow7iYKCivp0RfukDrbB0i/se5ACnBH2w9JQNsPyT8t6fhDLe0CiwN5n+1WegR4QniQ+AKAB+6QOsN4+O7neg5Gh+6HKgT7AhAH7pA6+O7negtGx+6HSiAhmEIC0AP4ARv655/tSEqf7Uha3+1IGp/tSBrf7UgK3+1IOmUQUBDI6wUIWCfw7kQqJe4hOjPuAQr/94v/sO5AirDuQwr/94X/xka17gB69u4AagbrBQy27ghqrkVY2gfukOr47ud6Z+6IWmDuJ3r97uVa/e7nehXukCoX7pA6dO5FWmTuoHr07uV68e4Q+sK/wRjC6wUJBPsBYfTux0rIvwH4CXDx7hD6Dd117gRa9O7levHuEPrBv8EawusFCQT7AWEB+Alw9O7mSvHuEPoL3XPuxVr07uV68e4Q+sK/wRoE+wEhAfgMcPTuxkrx7hD6C9117iNa9O7levHuEPrCvxsYBPsDIwP4DHAO8QEOpOc17gJatO7iWvHuEPqI2b3sAosBIL3o+IMAvwAAyEIAALRCAAAAADX6jjzbD8k/AAC0QwAAh0M=");
  return {
    circle:E.nativeCall(117, "int(int, int)", bin),
  };
})();
  
  var round = Math.round;
  function sin(x) {
    "compiled"
    var PI = 3.14159265358;
    // exploit symmetry - we're only accurate when x is small
    var xi = round(x/PI);
    x -= xi*PI;
    if (x>PI/2) x=PI-x;
    // Taylor series expansion of 'sin'
    var r = x; // running total
    var x2 = x*x; // precalculate x^2
    var xpow = x; // running power
    var factorial = 1; // running factorial
    var i;
    for (i=1;i<10;i++) {
      xpow = xpow*x2;
      factorial *= (i*2)*((i*2)+1);
      var term = xpow / factorial;
      if (i&1) r-=term; else r+=term;
    }
    // symmetry
    if (xi&1) r=-r;
    return r;
  }
  function cos(x) {
    "compiled"
    var PI = 3.14159265358;
    return sin(x + (PI/2));
  }
  function circle(params, data){
    "compiled"
    var w = params[0];
    var h = params[1];
    var margin = params[2];
    var p100 = params[3];
    var PI = 3.14159265358;
    var n = PI / 180.0;
    var p = p100 / 100.0;
    var thetaInc = params[4] / 100.0;
    for (var i=0; i<2500; i++) {
      data[i] = ' ';
    }
    for(var theta=0; theta<=90; theta=thetaInc+thetaInc) {
      var c = cos(theta * n);
      var s = sin(theta * n);
      var w2 = w/2;
      var h2 = h/2;
      for (var r = w2 - margin; r < w2; r++) {
        var x1 = round(r * c);
        var y1 = round(r * s);
        if (360 * p > 90 - theta) {
          var x = w2 - x1;
          var y = h2 + y1;
          data[w * y + x] = 'X';
        }
        /*if (p > 0.25 && 360 * p > 90 + theta) {
          var x = w2 - x1;
          var y = h2 - y1;
          data[w * y + x] = 'X';
        }
        if (p > 0.5 && 360 * p > 270 - theta) {
          var x = w2 + x1;
          var y = h2 - y1;
          data[w * y + x] = 'X';
        }
        if (p > 0.75 && 360 * p > 270 + theta) {
          var x = w2 + x1;
          var y = h2 + y1;
          data[w * y + x] = 'X';
        }*/
      }
    }
    return data;
  }
  
  function getCircle(ops) {
    const w = ops.w;
    const h = ops.h;
    const p = ops.p;
    const border = ops.border;
    const col = ops.col;
    // Uint8Array supports int up to 255, so max with and height is limited to that
    var params = new Uint8Array(5);
    params[0] = w;
    params[1] = h;
    params[2] = border || 1;
    params[3] = p * 100;
    params[4] = 100;
    if (w > 100) params[4] = 25;
    else if (w > 50) params[4] = 50;
    var data = new Uint8Array(w*h);
    var paramsAddr = E.getAddressOf(params,true);
    var dataAddr = E.getAddressOf(data,true);
    if (!paramsAddr) {
      params = E.toString(params);
      paramsAddr = E.getAddressOf(params,true);
    }
    if (!dataAddr) {
      data = E.toString(data);
      dataAddr = E.getAddressOf(data,true);
    }
    if (!paramsAddr || !dataAddr) throw new Error('Can\'t get data address');
    c.circle(paramsAddr, dataAddr);
    //circle(params, data);
    //console.log('DD1',data)
    //console.log('DD2',  E.toString(data))
    const img = Graphics.createImage(E.toString(data));
    img.width = w;
    img.height = h;
    img.bpp = 1;
    img.transparent = 0;
    img.palette = new Uint16Array([0, g.setColor(col).getColor()]);
    delete data;
    delete dataAddr;
    delete params;
    delete paramsAddr;
    return img;
  }
  
  
  class uiCircle {
    constructor(params) {
      params = params || {};
      this.id = params.id;
      this.type = 'custom';
      this.pad = params.pad || 0;
      this.width = params.width;
      this.height = params.height;
      this.border = params.border;
      this.p = params.p !== null && !isNaN(params.p) ? params.p : 1;
      this.cb = params.cb;
    }
    render(l) {
      l = l || this;
      const x = l.x + l.pad/2;
      const y = l.y + l.pad/2;
      const w = l.w - l.pad;
      const h = l.h - l.pad;
      g.drawImage(getCircle({ w: l.w, h: l.h, p:1, border: l.border, col: '#fff' }), x, y);
      g.drawImage(getCircle({ w: l.w, h: l.h, p: l.p, border: l.border, col: '#f00' }), x, y);
    }
  }
  
  
  
  var idx = 0;
  var steps = 40;
  var refresh = 200;
  var interval;

const testLayout = new Layout({
    type:"v",
    bgCol: g.theme.bg2,
    filly: true,
    c: [
      new uiCircle({
        id: 'circle1',
        height: 150,
        width: 150,
        pad: 4,
        border: 20,
        cb: () => {
          if (interval) stop();
          else start();
        }
      })
    ]
  });
  
  function start() {
    interval = setInterval(() => {
      testLayout.circle1.p = (1/steps) * (idx++%(steps+1));
      testLayout.render();
      //testLayout.clear(testLayout.circle1);
      //testLayout.render(testLayout.circle1);
    }, refresh);
  }
  function stop() {
    if (interval) clearInterval(interval);
    interval = null;
  }
  
  testLayout.render();